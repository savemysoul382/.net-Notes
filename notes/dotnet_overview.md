# # dotNET Overview

---

## #1 Что такое .Net

### Среда выполнения

 **Средой выполнения** можно назвать совокупность ресурсов необходимых для выполнения и в рамках которых выполняется программа. Например, к таким ресурсам можно отнести операционную систему, переменные окружения, доступ к определенным библиотекам необходимым для выполнения программы.

### Программное обеспечение

 Это собственно программа, которую мы планируем запускать в среде выполнения.

### Программа

*  В случае использования **интерпретируемого языка** программирования (например, PHP) программа взаимодействует со средой выполнения непосредственно в интерпретаторе языка. 

* при использовании **компилируемого языка** (например, C#) взаимодействие со средой выполнения реализовано посредством взаимодействия промежуточного кода, скомпилированного из исходного кода, со средой выполнения через подключаемые библиотеки.

### платформа .NET

* **<mark>Платформа .Net</mark> является компьютерной платформой или другими словами <mark>- это среда выполнения</mark>**

* преимуществ платформы .Net
  
  * **прощенная модель установки программного обеспечения** – в отличии от модели COM библиотеки .Net не регистрируются в системном реестре. Также несколько версий одной библиотеки .Net могут быть установлены на один компьютер. Более подробно об этом можно будет узнать, ознакомившись с ответом на вопрос, что такое Глобальный Кэш Сборок или на языке оригинала - *Global Assembly Cache*.
  
  * **Совместимость с существующим кодом** – существующее программное обеспечение COM может взаимодействовать с новым программным обеспечением .Net. Это взаимодействие также имеет и обратный характер – программное обеспечение .Net может работать с библиотеками COM.
  
  * **Поддержка большого числа языков программирования** – приложения .Net могут быть написаны, используя различные языки программирования (C#, Visual Basic, F#).

### Из чего состоит платформа .Net.

- общеязыковая исполняющая среда (**Common Language Runtime**);
  
  <mark>– это среда, в которой выполняется промежуточный код.</mark>
  
   Это компонент .NET Framework, основной <mark>задачей </mark>которого является <mark>управление интерпретацией и исполнением кода IL</mark>. CLR отвечает за <mark>изоляцию памяти приложений</mark>, <mark>проверку типов</mark>, <mark>безопасность кода</mark>, <mark>преобразование IL в машинный код</mark>.
  
  * Для определения чем является общеязыковая исполняющая среда (**Common Language Runtime**) необходимо понимание что представляют из себя понятия **IL (Intermediate Language)**, **MSIL (Microsoft Intermediate Language)** и **CIL (Common Intermediate Language)**. По большому счету все три вышеперечисленные понятия означают одно и то же – <mark>промежуточный язык, который компилируется из исходных языков .Net</mark> (C#, Visual Basic)
    
        Промежуточный код хранится в библиотеках .dll или .exe. Кроме промежуточного кода в данных библиотеках содержится детальное описание использованных типов – так называемые мета данные. В среде .Net такие библиотеки называются сборкой (assembly).

- Общая система типов (**Common Type System**);
  
  <mark>-- это формальная спецификация, определяющая как типы данных должны быть определены, чтобы их можно было использовать в общеязыковой исполняющей среде в дальнейшем.</mark>
  
  *  Когда речь идет о типах данных, то скорей всего имеется в виду один из элементов следующего списка: *класс*, *интерфейс*, *структура*, *перечисление* (enumeration), *делегат*.
  
  * Ниже пара слов о каждом типе данных:
    
    - **<mark>класс</mark>** – <mark>основа объектно-ориентированного программирования</mark>; Класс может содержать различные члены: поля, свойства, конструкторы, события, методы. Класс имеет следующее характеристики: запечатан ли класс, является ли класс абстрактным или конкретным, реализует ли класс какие-либо интерфейсы, какая у класса видимость.
    - **<mark>интерфейс</mark>** – <mark>это список функционала, который должен быть реализованы классом</mark>
    - **<mark>структура</mark>** – не вдаваясь в подробности реализации данного типа данных, можно просто сказать, что<mark> это «легковесная» версия класса</mark>. Наиболее частое применение структур — это моделирование математических, физических или геометрических данных.
    - **<mark>перечисление</mark>** – это <mark>удобный способ создания пар «ключ-значение»</mark>, которые легко использовать в различных частях нашего когда.
    - **<mark>делегат</mark>** – очень сильно упрощая делегатом можно назвать <mark>указатель на определённую функцию / метод в памяти</mark>, однако по сравнению с другими языками программирования в .Net делегат не является просто указателем на определенное место в памяти, а реализует в себе дополнительную полезную функциональность.

- **<mark>Common Language Specification</mark>** (общая спецификация языков);
  
  это <mark>набор правил</mark>, следуя которым разработчики достигают <mark>бесконфликтной работы во всех языках .NET</mark>.
  
   C точки зрения определенного функционала языки программирования .Net не совместимы.
  
  - Общая спецификация языков <mark>определяет минимальный набор функционала, который должен быть поддерживаться каждым .Net компилятором</mark>, чтобы скомпилированный код можно было выполнить в общеязыковой исполняющей среде в дальнейшем. То есть общая спецификация языков это<mark> набор правил, которые относятся к элементам, которые выставлены «наружу» и могут быть использованы другими языками .Net (например, публичные методы классов</mark>). Общая спецификация языков не ограничивает использование функционала конкретного языка во внутренней имплементации (например, приватные методы).

- **<mark>IL</mark>** (Intermediate Language)
  
  Код, содержащий <mark>набор инструкций</mark>, <mark>не зависящих от платформы</mark>. Иными словами, после компиляции исходного кода он преобразуется не в код для какой-то определенной платформы, а в промежуточный код на языке IL.
* В дополнение к вышеуказанным 3 элементом можно указать библиотеки базовых классов (**Base Class Libraries**).
  
  * Бд
  
  * Поточность
  
  * Файлы
  
  * UI
  
  * Security
  
  * API

### Код

* <mark>Управляемый код</mark>
  
  * это код,<mark> который можно запустить на платформе .Net </mark>(например, код C#); библиотеки, которые содержат управляемый код, называются сборкой (assembly).

* <mark>Неуправляемый код</mark>
  
  * это код, который <mark>не может быть непосредственно запущен на платформе .Net</mark> (например, неуправляемое приложение в C/C++).

---

## #2 Разница между объектом и классом

 **<mark>Класс</mark>** —<mark> это формальная запись свойств объекта</mark> в соответствии с синтаксисом данного языка программирования. А <mark>объектом</mark> данного класса является нечто, иногда говорят <mark>инстанция</mark>, <mark>с характеристиками описанными в классе</mark>, которые имеют определенное значение. Работая с классами в C# и декларируя классы, вы будете постоянно сталкиваться с этими понятиями:

    1) Под *<mark>объектом</mark>* в ООП понимается <mark>некая сущность</mark> (иногда называемая <mark>инстанцией класса</mark>), которая <mark>является представителем определенного класса</mark>.

    2) <mark>Класс </mark>— это <mark>совокупность параметров, которые характеризуются и описывают объект</mark> – представитель класса.

- свойства;
- методы;
- поля;
- события;
- конструктор;
- зависимости;

    Каждый предмет - это объект.

Чем может характеризоваться объект? Для наглядности возьмем телевизор. 

* "Свойства": 
  
  * диагональ телевизора;
  
  * цвет корпуса;
  
  * цена телевизора;

* "Методы":
  
  - просмотр телевизионных программ;
  - просмотр видео на YouTube;
  - запуск браузера и просмотр интернет страниц;

* "Поля":
  
  Эти параметры существенны, и они влияют, скажем так, на качество изображения, но они как бы скрыты от нас.
  
  *  емкость конденсаторов и сопротивление резисторов

* "События":
  
  Назовём нажатие кнопки **событием** и договоримся, что каждое событие может иметь **обработчик события** (реакция на определенное событие).
  
  * Нажатие кнопок на пульте, чтобы переключить каналы

* "Конструктор и зависимости":
  
  Компоненты, из которых мы собираем телевизор, как конструктор назовём **зависимостями**.
  
  * - аудио плата отвечает за воспроизведение звука;
    - плата WiFi необходима для подключения к беспроводным сетям;
    - ТВ тюнер необходим для получения и обработки сигнала с телевизионной антенны;

---

### #3 Принципы объектно-ориентированного программирования

- Абстракция - отделение идеи от реализации

- Полиморфизм - реализация идеи разными способами

- Наследование - повторное использование кода лучше реализовать с помощью агрегации или, что хуже, композиции)

- Инкапсуляция - приватные методы

**<mark>ООП</mark>** - <mark>программирование, которое ориентировано на объекты.</mark>

Это такой способ программирования, при котором наша работа сконцентрирована на объектах и работе с ними.

* <mark>Объект</mark> в ООП понимается некая <mark>сущность </mark>(иногда называемая <mark>инстанцией класса</mark>), которая <mark>является представителем определенного класса</mark>.

* <mark>Класс </mark>— это <mark>совокупность параметров, которые характеризуются и описывают объект</mark> – представитель класса.

То есть, *все объекты являются представителями определенных классов*.

Например, <mark>лев </mark>– это <mark>представитель класса животные</mark>.

 Исходя из этого в **объектно-ориентированном программировании** мы <mark>работаем с объектами представителями определенных классов</mark>

    3 принципа ООП:

* **<mark>Инкапсуляция</mark>**
  
  Это <mark>сокрытие специфики кода класса</mark>.
  
  * пользователя интересует конкретная функциональность, а не детали её работы
  
  * позволяет показать конечному пользователю класса функциональность и данные, которые действительно ему будут необходимы для выполнения определенных задач
  
  * мы защищаем объекты нашего класса от несанкционированного изменения их состояния
  
  * мы выставляем на внешний мир только то, что действительно необходимо пользователям нашего класса

* **<mark>Наследование</mark>**
  
   <mark>переход определенных свойств от родителя к наследнику</mark>, то есть ребенку
  
  * имея определенный класс - родитель мы можем создать новый класс - наследник, который унаследует всё свойства класса-родителя и который может (но не должен) иметь дополнительные свойства и функциональность. В данном случае возникает отношение **«B является А»**, если класс В наследует по классу А. По сути класс В получает всё свойства класса А

* **<mark>Полиморфизм</mark>**
  
  «полиморфизм» — <mark>это свойство объекта определенного класса быть</mark> <mark>использованным как объект другого класса.</mark>
  
  Первая часть «поли» - означает «<mark>много</mark>», а вторая «морф» - означает «<mark>жизнь</mark>»
  
     Имеем 2 класса: «А» и «В». «В» наследует «А». То есть справедливо утверждение «В является А». Утверждение «В является В» также является справедливым. То есть объект класса «В» может быть использован как объект класса «А» и как объект класса «В». В этом свойстве проявляется **полиморфизм** класса «В» - упрощая, объект класса «В» одновременно является объектом класса «А» и объектом класса «В». Итого, у объекта «В» есть 2 «жизни» - «А» и «В».
  
    Объясним это на примере. Дано – класс «Животное», который умеет делать только одну вещь – двигаться. Класс «Животное» наследуют 3 класса: «Птица», «Рыба», «Сухопутное млекопитающее». Каждый из 3 перечисленных классов получает от своего родителя, класса «Животное», функциональность «двигаться», но реализует её по-своему. «Птица» летает, «Рыба» плавает, «Сухопутное млекопитающее» ходит на лапах. Допустим у нас есть набор, состоящий из одного объекта каждого класса: «Орел», «Акула» и «Лев». Мы можем заставить двигаться эти объекты обращаясь к каждому из этих объектов и выполняя соответствующую команду «лети», «плыви», «беги». Но зная, что каждый из этих объектов является объектом класса «Животное», мы можем упростить задачу и выполнить универсальную команду «двигайся». Нам важно чтобы эти объекты начали перемещение, а не то, как эти объекты будут фактически передвигаться (лев побежит, акула поплывёт, а орёл полетит). Использование классов-родителей (или, более грамотно, базовых классов) и **полиморфизма** позволяет избежать дублирования кода и даёт возможность упростить код, одновременно улучшая его понимание при чтении кода другими программистами.

---

### #4 Модификаторы доступа

**Модификатор доступа** — это специальная <mark>инструкция </mark>в синтаксисе языка C#, которая<mark> определяет уровень доступность конкретного члена класса или самого</mark> <mark>класса в целом</mark> для конечного пользователя нашего класса или сборки.

- **public** – публичный – ограничения доступа отсутствует, каждый пользователь нашего класса или сборки имеет доступ к этому классу;
- **internal** – внутренний – к данному классу есть доступ только в текущей сборке; то есть если программист получил доступ к сборке (например есть доступ к файлу .dll), то у него не будет доступа к классу обозначенному модификатором доступа **internal**. Однако если Вы программист, который работает с конкретной сборкой, то у Вас будет доступ ко всем классам обозначенным модификатором доступа internal в рамках данной сборки.
- **protected** – защищенный – члены класса обозначенные этим словом доступны в текущем классе и во всех классах которые наследуют данный класс;
- **protected internal** – защищённый внутренний – члены класса обозначенные этим словом доступны в текущей сборке и в классах которые наследуют данный класс.
- **private** – частный – доступ к членам класса обозначенным этим словом ограничивается только текущем классом. В классах, которые наследуют данный класс, доступа к членам **private** базового класса не будет – для разрешения данной ситуации необходимо использовать **protected**;

При ответе на вопрос важно понимать, с какими типами данных мы можем использовать модификаторы доступа и какие значения модификаторов доступа у определенных типов данных определены по умолчанию.

- элементы определяемые непосредственно в namespace, то есть класс, структура, интерфейс, enum могут быть **public** или **internal**. Если мы не укажем модификатор доступа перед декларацией, то тип будет считаться **internal**;
- для членов класса могут использоваться всё 5 вышеуказанных модификаторов доступа;
- для членов структуры – со структурой могут использоваться только 3 из 5 вышеперечисленных модификаторов доступа: **public**, **internal**, **private**. Запомнить их легко, так как в структурах нельзя использовать модификаторы **protected**. Давайте на секундочку остановимся и подумаем почему. Модификаторы доступа **protected** используются чтобы дать доступ к своим членам в классах, которые наследуют текущий класс. Но структуры нельзя наследовать. Соответственно необходимость в использовании **protected** отпадает. Если мы не укажем модификатор доступа перед декларацией структуры, то структура будет считаться **private**.

---

### #5 Наследование, ключевые слова

Класс-наследник может наследовать только одного класса-родителя. В зависимости от того, как задекларирован класс-родитель, на программиста может быть наложено обязательство добавить реализацию определенной функциональности в классе-наследнике.

  Что такое сигнатура метода? <mark>Сигнатура </mark>– от латинского „signatura”, ручная подпись или просто подпись - <mark>набор аргументов метода по типу и порядку</mark>, а <mark>также тип возвращаемого значения метода.</mark>

Также существует возможность добавить <mark>новые члены</mark> в <mark>класс «В»</mark>, которые будут <mark>такими же, как существующие члены класса «А».</mark>

* **<mark>new</mark>**
  
  * В этом случае для такого члена в классе «В» используется **ключевое слово „<mark>new</mark>”**. Это даёт <mark>указание компилятору</mark> <mark>использовать реализацию определенного члена</mark> <mark>в классе «В», не используя такой же по сигнатуре член в базовом классе</mark> (классе-родителе). Однако следует помнить, что если программист обратится к классу «В», как будто бы это был класс «А» (полиморфизм), то будет использована реализация члена в классе «А». Даже несмотря на то, что в классе «В» есть другая реализации этого члена с **ключевым словом «new»**.

* <mark>**virtual**</mark>
  
  У нас есть возможность переопределить в классе «В» методы **с ключевым словом „virtual”**. Естественно, сигнатуры методов должны совпадать. Также перед данным методом в классе «В» необходимо использовать **ключевое слово «override»**.
  
    Обоснованный вопрос – чем отличается использований ключевых слов **“new”** и **„override”**. Как работает **ключевое слово “new”** описано в сценарии 1. Что касается **ключевого слова „override”**, то независимо от того, как программист будет обращаться к классу «В» - как к классу «В» или как к классу «А» - всегда <mark>будет использована</mark> самая низкая (или последняя) версия метода в иерархии наследования, то есть будет использована <mark>версия </mark>с **ключевым словом „<mark>override</mark>”**, а если таковой не будет – то будет использована версия с **ключевым словом „virtual”.
  
  **Важное замечание – если будет создан класс «С», наследующий класс «В», то в классе «С» также можно переопределить методы, обозначенные словами **„virtual”** и **„override”** в родительских классах «А» и «В». Действие этих ключевых слов не ограничивается уровнями наследования.

* **<mark>abstract</mark>**
  
  **<mark>Абстрактный класс</mark>** – это класс, который <mark>обозначен ключевым словом</mark> „<mark>abstract</mark>” <mark>и содержит абстрактные методы</mark>. Второе условие необязательно, но без него создание абстрактного класса не имеет смысла.
  
  <mark>**Абстрактный метод**</mark> – метод, <mark>который не содержит реальной реализации</mark>, а только <mark>определяет сигнатуру метода и обозначен ключевым слово „abstract”.</mark> Предполагается, что конкретные реализации (имплементации) абстрактного метода будут представлены в классах наследниках абстрактного класса с абстрактными методами.
  
    **Абстрактные и виртуальные методы** можно переопределять в классах – наследниках, а в случае абстрактных методов – это надо делать обязательно. **Виртуальные методы** необходимо использовать, когда необходимо дать конечным пользователям имплементацию по умолчанию, которую можно переопределить или оставить как есть. <mark>**Абстрактные методы**</mark> используются, когда нет имплементации по умолчанию и<mark> в каждом классе-наследнике</mark> данный абстрактный метод <mark>необходимо переопределить</mark>.

* **<mark>sealed</mark>**
  
  <mark>Ограничить возможность наследования класса

Подведем итоги:

- классы могут быть абстрактными и конкретными;
- можно наследовать как абстрактные, так и конкретные классы;
- ключевое слово *„sealed”* перед декларацией класса запрещает наследование класса;
- методы могут быть обычными, виртуальными (*virtual*) и абстрактными (*abstract*);
- обычный метод можно переопределить в классе-наследнике используя ключевое слово *„new”*;
- виртуальные и абстрактные методы можно переопределять в классе-наследнике используя ключевое слово *„override”*;
- мы можем, но не обязаны, переопределять виртуальные методы в классе-наследнике;
- мы обязаны переопределять абстрактные методы в классе-наследнике, однако если класс-наследник абстрактный, мы не обязаны это делать;
- следует помнить о разнице между ключевыми словами *„new”* и *„override”*;

---

## #6 Interfaces

**<mark>Интерфейс</mark>** —<mark> это набор абстрактных членов, которые декларируют определённый функционал.</mark>

* В языке C# можно декларировать 4 типа членов: 
  
  * **методы**, **свойства**, **события** и **индексы**.

## #7 Разница между абстрактным классом и интерфейсом.

### Абстрактные классы

* при наследовании абстрактного или конкретного класса мы получаем весь функционал этого класса (кроме членов, обозначенных модификатором доступа private) даже если он не имеет смысла в нашем классе.

* Можем наследовать только 1 класс

### **Интерфейсы**

* Класс может реализовывать один или несколько **интерфейсов**

* при имплементации интерфейса мы получаем конкретный список членов, которые должны быть реализованы в нашем классе.

---

### #8 Виды циклов

* <mark>**for**</mark>
  
  необходимо выполнить **цикл операций <mark>определенное количество раз</mark>**
  
  Для **оператора for** важно задекларировать переменную счетчика и присвоить ей первоначальное значение; далее необходимо указать условие, по которому цикл прерывается и, наконец, указывается способ изменения значения счетчика.

* <mark>**foreach**</mark>
  
  Если вам необходимо **<mark>перебрать все элементы</mark>**
  
   Важное замечание – так называемый контейнер(<mark>коллекция</mark>), который вы планируете использовать в операторе foreach, <mark>должен реализовывать</mark> <mark>**интерфейс IEnumerable**.</mark>
  
  Особенностью цикла foreach является работа в одном направлении – перебор элементов коллекции начинается с первого элемента и заканчивается последним

* <mark>**while и do/while**</mark>
  
  * **Цикл <mark>while</mark>** будет выполнятся<mark> пока выполняется условие</mark> выполнения цикла.
    
    Может случится так, что условие выполнения цикла изначально не выполняется – в таком случае операция или операции в цикле while не выполнятся ни одного раза.
  
  * <mark>**do/while**</mark>
    
    Оператор гарантирует <mark>выполнения </mark>команд в цикле <mark>хотя бы один раз</mark>.

---

### #9 Как работает foreach

 **Foreach** используется в ситуациях когда Вам необходимо <mark>перебрать всё</mark> <mark>элементы</mark> в коллекции и<mark> в процессе</mark> перебора элементов <mark>выполнить </mark>над ними какие-то <mark>операции</mark>.

**<mark>LINQ</mark>** – это сокращение на английском языке, которое означает *Language Integrated Query* (язык интегрированных запросов). Выражение **LINQ** это <mark>инструмент</mark>, при помощи которого, можно в<mark>ыполнить запрос</mark> <mark>к</mark> определенной <mark>коллекции кратко и понятно</mark>, что улучшает читаемость кода и облегчается работу с этим кодом.

    Так вот, если мы припишем какой-либо переменной <mark>значение выражения **LINQ**</mark>, то в этом переменной будет <mark>сохранено выражение **LINQ**,</mark> а <mark>не результат этого выражения</mark>. Такое поведение является одной из особенностей выражений **LINQ** и называется оно - *отложенное выполнение*.

    Итак, что необходимо сделать, чтобы получить результат выражения **LINQ** из переменной с выражением **LINQ**. Сначала необходимо подумать - чем является результат выражения **LINQ**. Как правило, результатом выражения **LINQ** является коллекция. А если это коллекция, значит мы можем использовать для перебора данных, которые содержаться в данной коллекции, оператор цикла **foreach**. То есть работа оператора **foreach**, кроме всего прочего, характеризуется стартом отложенного выполнения выражения **LINQ**.

    С какой целью в выражениях **LINQ** используется<mark> отложенное выполнение? </mark>Цель следующая – при каждом переборе результатов выражения **LINQ** вы должны <mark>получить самые новые и актуальные данные</mark>. <mark>Возможно, произошли какие-то изменения с вашими коллекциями</mark> <mark>и результат выражения **LINQ** изменился</mark>. Благодаря отложенному выполнению <mark>вы получить этот самый новый</mark>, самый актуальный, измененный <mark>результат </mark>выражения **LINQ**.

    Использование в синтаксисе оператора цикла **foreach** не является единственным способом материализовать результат выражения **LINQ**. Однако остальные способы материализации результата так или иначе связанны с перебором элементов коллекции, которые возвращаются в виде результата выражения **LINQ**.

---

### #10 Что такое атрибуты

- <mark>Атрибуты </mark> это определённые <mark>данные</mark>, которые <mark>описывают сам код</mark> и в зависимости от значений этих данных <mark>возможно влияние на работу кода</mark>

- **Атрибут** (attribute) - это<mark> универсальное средство связи данных с типами</mark>, позволяют добавлять любую текстовую информацию о классах, свойствах, методах и т.д. Атрибуты сохраняются с метаданными и могут быть получены при выполнении программы.

    Представим, что <mark>код </mark>— это <mark>набор </mark>определенных <mark>инструкций</mark>, тогда <mark>атрибутами </mark>можно назвать <mark>советы как выполнить</mark> данные <mark>инструкции </mark>наилучшим образом или наиболее эффективно. Всё зависит от действий предпринятым программистом в ответ на наличие **атрибутов**.

    **Атрибуты** могут быть добавлены к различным частям кода: к декларациям классов, методам, свойствам, аргументам.

    **Атрибуты** сами по себе пассивны – они не выполняются, как код, а только содержат значения, которые мы можем использовать для управления работой кода.

Как программисты могут <mark>определить есть ли в коде атрибуты</mark> не имея доступ к исходному коду. Для этих целей <mark>используется **рефлексия**.</mark> **<mark>Рефлексия</mark>** – это <mark>процесс</mark>, во время которого <mark>программа может отслеживать</mark> и модифицировать <mark>собственную структуру и поведение во время выполнения</mark>. Одной из функций рефлексии является **чтение атрибутов**. Используя рефлексию, можно определить есть ли в данном месте (в декларации класса, метода, свойства, аргумента) атрибут определенного типа и если да, то получить объект атрибута данного типа, через который мы получаем доступ к значениям данных атрибута.

Где атрибуты встречаются наиболее часто:

- в **модульных тестах**: атрибуты определяют в какой последовательности должен выполняться код модульных тестов и что конкретно должно выполняться во время тестирования. Например, мы можем обозначить атрибутом метод, который должен выполняться перед модульным тестом – для инициализации первичных значений переменных в тесте.
- в коде связанным с управлением **сериализацией** и **десериализацией**. **Сериализация** это перевод данных программы в последовательность битов, а **десериализация** это обратный процесс. Используя атрибуты, мы можем управлять эти процессом. Код, который выполняет сериализацию / десериализацию ищет все атрибуты связанные с сериализацией и в зависимости от их значения предпринимает определенные действия, которые влияют на конечный результат сериализации.
- в **ASP.NET MVC** атрибуты используются для определения валидации на свойства классов – моделей.

Что еще можно сказать об атрибутах? К одному члену можно приписать не только один, а даже **несколько атрибутов**. Можно также ограничить использование атрибутов только для определенных членов – например **атрибут только для классов** или только для свойств.

---

### #11 Ссылочные и значимые типы

* <mark>**Стек**</mark>
  
  Стек в той или иной степени отвечает, что в данный момент выполняется в нашем коде,

* <mark>**Куча**</mark> 
  
  В куче хранятся наши данные

В языке существует 4 главных типа: **значимые типы**, **ссылочные типы**, **указатели** и **инструкции**.

**Значимые типы** – это типы, которые наследуют тип System.ValueType, например bool, int, long, decimal, enum и другие.

**Ссылочные типы** – это типы, которые наследуют тип System.Object, то есть class, interface, delegate, string. Object также является ссылочным типом, но он не наследует System.Object, а является этим типом.

**Указатель** или <mark>**ссылка**</mark> – это <mark>то, что связывает определенный тип</mark> <mark>с его значением в памяти</mark>. Указатель может находиться в стеке или в куче, но указывает на определенное место в куче. Программисты C# не используют указатели непосредственно. За них это делает Common Language Runtime. Возвращаясь к предыдущему пункту – если мы говорим, что что-то является ссылочным типом, то это означает, что мы обращаемся к этому типу через ссылку или указатель. Значением указателя может быть адрес памяти или null. Отсюда можно сделать выводы что значимые типы не могут иметь значение null – они всегда имеют значение по умолчанию для своего типа, например для int это 0.

**<mark>Инструкции</mark>** – по сути <mark>это</mark> наши <mark>методы </mark>с набором команд, которые необходимо выполнить.

Вопрос что и где хранится в памяти?

- **Ссылочные типы** всегда хранятся в **куче**.
- **Значимые типы** и указатели хранятся в том месте, где они были задекларированы. Что это значит? Это значит, что если значимый тип был задекларирован как часть метода, то он будет размещен в стеке, однако если значимый тип является часть ссылочного типа, то он будет размещен в куче.

Что еще необходимо знать о **значимых** и **ссылочных** **типах**?

- работая со значимым типом, мы всегда работаем с его конкретным значением;
- работая со ссылочным типом мы всегда работаем с указателем на этот тип в памяти – стоит помнить что таких указателей может быть несколько и соответственно значение в памяти может быть изменено в нескольких местах в коде.

---

### #12 Ключевое слово yield

Оператор yield — <mark>специальный оператор генерации блока итератора</mark>.

Ключевое слово **yield** появляется в контексте работы с коллекциями и перебором элементов этих коллекций. Как правило коллекции реализуют интерфейсы **IEnumerable** и **IEnumerator**, что позволяет с легкостью перебирать элементы этих коллекций с помощью оператора **foreach**.

* **MoveNext**

* **HasNext**

* **Current**

Ключевое слово **<mark>yield</mark>** <mark>позволяет создавать «на лету» итератор для коллекции</mark> с методами, указанными выше. Что дает нам получение итератора? Для <mark>коллекции</mark>, <mark>которая не реализовала интерфейсы **IEnumerable** и **IEnumerator**</mark> можно с легкостью их реализовать, чтобы данную коллекцию можно было использовать в петле **foreach** или как аргумент в методе **LINQ**.

---

### #13 Можно ли наследовать структуры

Итак, какие **ограничения** наложены **на структуры**:

- нельзя наследовать структуры;
- структуры не могут наследовать другие структуры и классы;
- каждая структура по умолчанию уже содержит конструктор без параметров независимо от того был ли добавлен конструктор с параметрами или нет;
- если был добавлен конструктор с параметрами (как минимум с 1 параметром), то все поля и свойства структуры должны быть инициализированы;
- нельзя инициализировать поля в структуре.

Что **можно делать со структурами**:

- структуры могут наследовать интерфейсы;
- в структуре всегда доступен конструктор без параметров;
- всё структуры наследуют System.Object а это значит, что у программиста есть доступ к методам ToString, GetHashCode, Equals, GetType;

---

### #14 Что такое Garbage Collector

- *<mark>Когда Garbage Collector начинает удалять неиспользуемые данные</mark> из кучи в памяти?* - Garbage Collector начинает удаление объектов, когда на куче <mark>отсутствует место для создания нового объекта</mark> или оп<mark>ерационная система сигнализирует отсутствие свободного места в памяти</mark>. Как правило очистка происходит тогда, когда приложении наименее нагружено.

- *<mark>Почему </mark>Garbage Collector начинает удалять неиспользуемые данные из кучи только в таких исключительных случаях?* – Очистка памяти – <mark>это ресурсоемкий процесс</mark>, к тому же <mark>состояние объектов</mark>, которые остаются в памяти <mark>должно быть неизменно</mark>, поэтому <mark>работа</mark> всех <mark>потоков</mark>, связанных с приложением, <mark>приостанавливается</mark>. Из этого следует, что процесс очистки памяти не может запускаться слишком часто, так как это будет значительно влиять на производительность нашего приложения.

- *Как Garbage Collector знает, <mark>какие объекты должны быть удалены?</mark>* – Объекты на куче, <mark>на которые отсутствуют ссылки в стеке</mark> являются объектами, которые будут удалены Garbage Collector’ом. Давайте еще раз разберем это предложение. Чтобы получить доступ к объекту в памяти из нашего кода у нас должна быть ссылка на объект, которая расположена на стеке. Если такое ссылки нет, то это значит, что мы не можем воспользоваться объектом на куче – у нас просто нет к нему доступа. Если у нас нет доступа к объекту, и мы не можем им воспользоваться, то такой объект на куче является бесполезным и будет удален сборщиком мусора.

- *<mark>Что </mark>конкретно <mark>делает </mark>Garbage Collector <mark>во время очистки памяти?</mark>* – Сборщик мусора действует по принципу «помечай и собирай». Во время очистки он «<mark>помечает</mark>» и<mark>спользуемые объекты и «собирает» их все вместе</mark> в определенном месте в памяти, делая размещение данных в памяти <mark>более компактным</mark>. Также после перемещения объектов в памяти восстанавливаются указатели на эти объекты.

- *Что происходит с <mark>объектами</mark>, которые <mark>«пережили» очистку</mark> Garbage Collector?* – Изначально объекты приписываются к так называемой «<mark>генерации 0</mark>». <mark>Если </mark>объекты <mark>не были удалены</mark> во время очистки, то высока вероятность что данные объекты являются важными и будут существовать в приложении еще како-то время. Такие объекты приписываются к «<mark>генерации 1</mark>». Есть еще «<mark>генерация 2</mark>», в которую попадают все объекты, <mark>которые остались </mark>в памяти <mark>после двух и более очисток.</mark>

- *<mark>С какой целью объекты в памяти приписываются к определенным генерациям</mark> Garbage Collector’ом?* – Как уже было сказано, очистка памяти – это ресурсоемкий процесс, и он занял бы значительное время при проверке всех объектов. Д<mark>ля минимизации времени работы</mark> <mark>Garbage Collector’а</mark>, при первой попытке очистки – проверяются объекты только «<mark>генерации 0</mark>». <mark>Если </mark>был <mark>освобожден достаточный объем</mark> памяти, <mark>то</mark> больше <mark>ничего не происходит</mark>, работа Garbage Collector’а прекращается. Однако если памяти всё еще недостаточно, начинается очистка объектов «генерации 1», и так далее до «генерации 2».

- *Можно ли программно <mark>вызвать очистку памяти</mark> Garbage Collector’ом?* – Можно. Для этого используется статический метод <mark>System.GC.Collect(),</mark> однако, как правило, этот метод используется довольно редко. Примеры <mark>ситуаций </mark>когда необходимо явно вызвать очистку: 1. <mark>Перед началом исполнения кода</mark>, который не может (и не должен) быть прерван<mark> Garbage Collector’ом во время исполнения</mark>. 2. После создания большего количества объектов в приложении, необходимо очистить памяти и освободить некоторые ресурсы.

### #15 Что такое enum

**enum** – это определенный тип данных. (значимое)

Данный тип является значимым. По факту при декларировании этого типа существует привязка к значениям типа int. Например указывая везде в коде значение Director, по факту приложение использует значение типа int 0.

Естественно, это не всегда удобно использовать нумерацию от 0. При декларировании типа enum программист может задать конкретные значения типа int каждому из возможных значений enum.  
Стоит также добавить, что значения int могут быть разными и не обязательно должны идти по порядку.

Иногда возникает потребность изменить привязку к типу int. Это также возможно. Привязку можно поменять на любой из доступных **значимых** типов определенных в .NET. Тип enum получает функциональность типа **System.Enum**, среди которой есть метод **GetUnderlyingType**. Этот метод позволяет получить тип, к которому осуществлена привязка типа **enum**.

---

### #16  Что такое delegate

1. **Можно ли создать такую переменную, к которой в качестве значения будет приписана ссылка на метод?**
   
   **Ответ на вопрос 1.** Да, можно создать <mark>переменную, к которой можно приписать ссылку на метод</mark>. В языке C# такая переменная будет называться **делегатом**. Расширяя определение делегата, данное в предыдущем предложении, стоит сказать что при декларировании делегата необходимо указать сигнатуру метода, который можно будет приписать данному делегату. **Сигнатурой метода** называется определенный набор аргументов метода по типу, количеству и порядку. В одном из предыдуших видео, посвященному ключевым словам при наследовании, я ошибся, сказав, что в сигнатуру метода входит также и тип возвращаемого значения. Исправляю свою ошибку – в сигнатуру метода тип возвращаемого значения не входит.

2. **Можно ли к такой переменной приписать любой метод?**
   
   Ответ на вопрос 2. Исходя из вышесказанного, к **делегату нельзя приписать** любой метод. К делегату может быть приписан метод, который имеет сигнатуру соответствующую сигнатуре делегата.

3. **Можно ли к такой переменной приписать несколько методов?**
   
   Да, к **делегату можно приписать** несколько методов которые имеют соответствующую сигнатуру. В этой же ситуации некоторые или все методы можно «отписать» от делегата.

4. **Как такую переменную можно использовать и что будет являться результатом этого использования?**
   
   <mark>**Делегат** является переменной, которая содержит указатель на метод</mark> <mark>или методы</mark>. Соответственно используя делегат мы можем вызывать методы, указатели на которые содержит делегат. Результатом использования делегата будет выполнение метода и, если необходимо, возвращение результата выполнения метода.

5. **Существуют ли в языке C# предопределенные переменные такого типа?**
   
   Да, в языке C# существуют **предопределенные делегаты**. Перед их более детальным рассмотрением, подумаем зачем они были созданы. В обычной ситуации созданный делегат будет использоваться скорей всего в одном месте в коде, использование его повсеместно будет затруднено в силу его узкой специализации или специфического названия, которое может не подходить к некоторым контекстам. В связи с этим часто бывают ситуации, когда имя делегата по сути не важно, но важно чтобы был определенный делегат с определенной сигнатурой. С этой целью возникли предопределенные делегаты – существуют 2 большие группы таких делегатов **Action** и **Func**. Это обобщенные делегаты, которые могут принимать до 16-ти типовых параметров. Отличие этих групп состоит в следующем – делегаты **Action** соответствуют методам, которые не возвращают значения (то есть возвращают void), а делегаты **Func** соответствуют методам, которые возвращают значение. Последней типовой параметр в делегате **Func** – это тип возвращаемого значения.

---

### #17 Многопоточность - введение

**<mark>Поток</mark>** – это <mark>путь или порядок</mark> <mark>выполнения определенных операций</mark> <mark>в границах приложения</mark>.

Потоки существуют внутри процессов.

По сути, программе, чтобы работать, необходим не только код программы, но и различные ресурсы (память, процессорное время, доступ к библиотекам). Когда приложение запускается пользователем, оно загружается в память, получает доступ ко всем необходимым ресурсам для своей работы и становится процессом.

<mark>Поток</mark>, и процесс <mark>служат для разделения работы.</mark>

- **поток** следует выбрать для относительно легковесных операций, а **процесс** для «тяжелых» операций, которые можно «подогнать» под отдельное приложение;
- **каждый процесс** имеет свое определенное место в памяти, а поток <mark>пользуется памятью процесса, в рамках которого они созданы;</mark>
- коммуникация между отдельными процессами относительно медленная, по сравнению с коммуникацией между потоками в рамках одно процесса, который пользуются одинаковым пространством памяти (это следует из предыдущего пункта);
- также из второго пункта следует, что <mark>у</mark> нескольких <mark>процессов нет</mark> <mark>общей памяти</mark>, а<mark> у потоков – есть</mark>. В случае потоков – это, может быть как преимуществом, так и недостатком, всё зависит от того, как мы будем рассматривать эту проблему.

В настоящее время большая часть компьютеров, если не все, обладают многоядерными процессорами, что в свою очередь позволяет выполнять **операции в потоках параллельно**. Означает ли это, что число одновременно созданных потоков может быть меньше или равно число ядер процессора? Нет, <mark>потоков может быть значительно больше</mark> <mark>(чем ядер)</mark>, однако в данном случае уже будет иметь место конкуренция между потоками за процессорное время. То есть используя специальные алгоритмы время процессора будет разделено между потоками и <mark>процессор будет постоянно переключаться между потоками</mark> <mark>по чуть-чуть выполняя каждый их них</mark>. Время переключения между потоками настолько ничтожно (его обычно называют **slice time**), что как правило им пренебрегают и его не учитывают. В этом заключается явление конкуренции между потоками за процессорное время. С точки зрения обычного пользователя может казаться что все потоки выполняются одинаково и прогрессируют в равной степени, но по факту в определенную единицу времени, пусть это будет миллисекунда, выполняется только один поток только одним процессором.

Также при непродуманном программировании многопоточного приложения возможно возникновение таких негативных явлений, как **race condition**, **live lock** и **dead lock**. Естественно, в языке C# существует специальные конструкции целью которых является упрощение многопоточного программирования:

- выражение lock;
- мониторы;
- специальные атрибуты;
- специальный синтаксис для явного и неявного создания потоков;
- специальные библиотеки для параллелизации вычислений;
- специальные коллекции для работы в многопоточной среде;

---

### #18 Многопоточность - создание потоков

Создание потоков:

* <mark>**Thread</mark>**
  
  * Это **явное создание потока**
  
  * для каждого отдельного задания необходимо создавать новый поток. Нельзя переопределить в объекте потока задание. То есть <mark>один поток</mark> – <mark>это одно задание.</mark>

* **<mark>ThreadPool</mark>**
  
  * Основан <mark>на повторном использовании</mark> уже <mark>существующих потоков</mark>.
    
    - мы ставим в очередь определенное задание с помощью делегатов;
    - для выполнения задания выделяется поток из ThreadPool;
    - задание выполняется;
    - после выполнения задания поток возвращается в состояние ожидания или получает новое задание для выполнения;
  - нет необходимости создавать поток на каждое задание – повышение производительности предложения;
  
  - ThreadPool поддерживает оптимальное количество потоков в системе – опять таки это положительно влияет на производительность приложения;
  
  - Вы, как программист, концентрируетесь на заданиях, на конкретной выполняемой задаче, а класс ThreadPool отвечает за оптимальное состояние инфраструктуры управления потоками;
  
  ```C#
  var thread = new Thread(new ThreadStart(SampleMethod));
  thread.Start();
  ```

* **<mark>Task</mark>**
  
  Задание — это определённая <mark>работа, которая может быть выполнена позже</mark>.
  
  ```C#
  Task task = Task.Run(() => SampleMethod());
  ```
  
  ```C#
  TaskFactory taskFactory = new TaskFactory();
  taskFactory.StartNew(() => SampleMethod());
  ```

При создании многопоточных приложений используется концепция асинхронного программирования. Мы запускаем какие-то методы результат которых будет доступен через некоторое время. Эти методы запускаются в отдельных потоках. Результатом выполнения такого метода является объект класса Task или значение его свойства Result. Чтобы создать такой метод необходимо использование 2 ключевых слов: **async** и **await**.

        Объекты класса Task имеет еще несколько интересных свойств. Например, их **можно соединять в цепочки**. То есть завершение одного задания запускает следующее, и даже более того – вы можете управлять тем, в каком случае необходимо запускать следующее задание. У вас есть несколько вариантов – новое задание запустится если:

- предыдущее задание отменено;
- предыдущее задание завершилось с ошибкой;
- предыдущее задание завершилось успешно;

Это возможность достигается путем использования слова метода **ContinueWith**. Еще одной интересной особенностью объектов класса Task является возможность определять в рамках одного задания **дочерние задания**. В этом случае родительский объект класса Task будет считаться завершенным, когда всегда все дочерние задания будут завершены.

---

### #19 Многопоточность - синхронизация потоков

- **Lock** / **Monitor** – работает в рамках приложения, в определённый момент времени к критической секции имеет доступ только один поток.
  
  Если посмотреть, что из себя представляет ключевое <mark>слово </mark>**lock** технически, то можно сказать, что это о<mark>бёртка над</mark> специализированным классом **<mark>Monitor</mark>**
  
  ```C#
  private object _syncObject = new object();
  public void MethodWithLock()
  {
      //код перед словом lock
      lock(_syncObject)
      {
      //код в критической секции
      //к данной секции имеет доступ только один поток в каждый момент времени
      }
      //код после слова lock
  }
  ```
  
  ```C#
  private object _syncObject = new object();
  public void MethodWithLock()
  {
      //код перед словом критической секцией кода
      Monitor.Enter(_syncObject);
      //код в критической секции
      //к данной секции имеет доступ только один поток в каждый момент времени
      Monitor.Exit(_syncObject);
      //код после критической секции
  }
  ```

- **Mutex** - работает в рамках операционной системы, в определённый момент времени к критической секции имеет доступ только один поток.

- **Semaphore** - работает в рамках операционной системы, в определённый момент времени к критической секции имеет доступ несколько потоков, их количество определено в конструкторе класса Semaphore.

- **[ThreadStatic] атрибут**
  
  Если мы обозначим переменную, атрибутом **ThreadStatic**, то каждый поток будет иметь свой экземпляр такой переменной. Например, для каждого потока будет свой экземпляр переменной x:
  
  <mark>(переменные, которые для каждого потока будут свои.)</mark>
  
  ```C#
  [ThreadStatic]
  private static int x
  ```

---

### #20 Многопоточность - коллекции

* **ConcurentBag<T>**
  
  это просто «мешок» для переменных, в который <mark>можно </mark>вкидывать <mark>дубликаты </mark>и <mark>нет </mark>особого <mark>порядка элементов.</mark>
  
  методы этой коллекции – это 
  
  * **Add**
  
  * **TryTake**
  
  *  **TryPeek**.

* **ConcurrentStack<T>**
  
   <mark>нет</mark> возможности <mark>доступа к элементам</mark> коллекции <mark>в произвольном порядке</mark>.
  
  В любой определенный момент времени <mark>доступен только один элемент</mark> коллекции. Для стэка – это элемент, который был <mark>добавлен последним</mark>.
  
  * **Push** 
  
  * **TryPop**

* **ConcurrentStack<T>**
  
  <mark>доступен</mark> <mark>только один</mark> элемент  – это элемент, <mark>который был добавлен первым.</mark>
  
  * **Enqueue** 
  
  * **TryDequeue**
  
  * **TryPeek** - получить элемент коллекции, не удаляя его

* **ConcurrentDictionary**
  
  <mark>Все операции</mark> связанные с работой коллекции <mark>выполняются</mark> <mark>как </mark>одношаговые <mark>атомарные </mark>операции.

* **BlockingCollection<T>**
  
  Коллекция называется блокирующей, потому что получения элемента может быть заблокировано до момента, когда данный элемент будет доступен.

---

### #21 Многопоточность - deadlock, livelock, starvation

* **Deadlock** рассмотрим на примере 2 потоков: *А* и *Б*. Потоку *А* для выполнение своих заданий необходимо выполнение некоторых заданий в потоке *Б*. С другой стороны потоку *Б* для выполнения некоторых своих заданий необходимо выполнение некоторых заданий в потоке *А*. Получается что в некоторых ситуациях <mark>поток *А* ждет поток *Б*, а поток *Б* в свою очередь</mark> <mark>ожидает поток *А*.</mark> Иногда такое ожидание может наступать одновременно:
  
  - поток А ждет поток Б;
  - поток Б ждет поток А;
  
  Во время ожидания ничего не происходит, это просто ожидание, однако в текущей ситуации такое ожидание будет продолжаться бесконечно: поток *А* никогда не дождется окончания операций потока *Б*, потому что поток *Б* не может дождаться окончания операций потока *А*. Это был классический пример **dealock**’а.

* **Livelock** – очень <mark>похож на deadlock</mark>, с той лишь разницей, что <mark>во время *livelock*’а</mark> <mark>потоки во время ожидания выполняют какие-то операции</mark>. Однако эти операции не имеют практического смысла, так как потоки несмотря на выполняемые операции и так не могут завершить свои задания. Также далее в видео будет практический пример *livelock*’а.

* **Starvation** – то есть «голод» - описывает ситуацию, когда несмотря на отсутствие deadlock’ов и livelock’ов, <mark>поток не может получить доступ</mark> <mark>к определенному ресурсу и завершить свою работу.</mark> Например, есть поток, который очень часто получает доступ к эксклюзивному ресурсу и долго выполняет свои операции используя эксклюзивный ресурс. Другие потоки, несмотря на отсутствие lock’ов не могут получить доступ к эксклюзивному ресурсу и выполнить свою работу. В этом случае имеет место явление старвации, то есть «голода ресурсов».

---

### #22 Ключевое слово static

Если во время программирования, вы создали класс, в котором нет внутреннего состояния, то самое время задуматься, а не сделать ли этот класс **статическим**.

*  статическом классе **<mark>нельзя </mark>использовать** ключевое слово **<mark>this</mark>**.

*  <mark>не можем создать</mark> <mark>объект статического класса</mark>

* статический класс <mark>создается </mark>п<mark>ри первом обращении</mark> к одному из его <mark>публичных членов</mark>.

* Обычный <mark>нестатический класс</mark> может иметь <mark>статические члены</mark>.

---

### #23 Обобщенное программирование в языке C#

* **boxing**
  
  <mark>Значимые типы</mark> x и y из стека и <mark>упаковать их в ссылочный тип object</mark>, то есть <mark>положить переменные</mark> x и y <mark>на кучу в памяти.</mark>

* **unboxing** - это обратный процесс. + мы всегда должны указать тип, к которому мы приводим результат.

**is**

- Оператор is возвращает значение типа bool, а также если возвращаемое значение – true, может создать переменную проверяемого типа и приписать ей значение,

- Оператор is может использоваться с любимыми типами,

**as** 

- оператор as если приведение удачно, возвращает объект приведённого типа с определенным значением или, если приведение не удалось, то возвращает null;

-  оператор as только со ссылочными типами;

**Обобщения**    

- параметров типа может быть более одного – в нашем конкретном примере мы использовали один параметр для простоты, но нам ничего не мешает создать класс который использует несколько параметров типа **SomeGenericClass<T1,T2,T3>**;

- мы можем оказывать влияние на то, как типы могут использоваться с нашим классом и об этом мы поговорим более подробно далее.

- Ограничения обобщений:
  
  * where T : struct
  
  * where T : class
  
  * where T : new()
  
  * where T : IDisposable <имя интерфейса>
  
  * where T : SomeBaseClass <имя класса>
  
  * class GenericClass<T, U> where T : U
    
    Тут мы имеем дело с обобщенным классом с двумя обобщенными параметрами типа и один тип Т должен наследовать другой тип U.

---

### #24 .Net Framework, .Net Core, .Net Standard

**.Net Framework**

- используя .Net Framework, мы можем написать приложение только для Windows
- мы можем написать микросервисы в .Net Framework, но такие сервисы могут быть установлены на серверах только с операционной системой Windows;
- можно ли использовать приложения написанные в .Net Framework с контейнерами Docker – да, можно, но это будет специальная версия Docker для Windows, то есть сервер должен быть на операционной системе Windows;
- в .Net Framework, в зависимости от подходов к программированию, также можно писать масштабируемые и эффективные приложения.

**.Net Core**

- кроссплатформенность
- поддержка микросервисов
- поддержка контейнеризации
- масштабируемость и эффективность
- поддержка командной строки

Минусы

- не поддерживаются приложения WindowsForms и WPF;
- услуги WCF не поддерживаются в .Net Core;
- не все библиотеки для .Net Framework имеют свои аналоги для .Net Core;
- библиотеки для .Net Core могут отличаться от библиотек .Net Framework, например Entity Framework Core это не тоже самое что Entity Framework;
- если у вас есть необходимость работы с определенными функциями операционной системы Windows, то .Net Core – это не самый лучший выбор, так как .Net Core – это платформа, которая не зависит от конкретных операционных систем.

**<mark>.Net Standard</mark>**

 **.Net Standard**, который имеет определенные версии предоставляет набор функционала в зависимости от выбранной версии. То есть .Net Standard это <mark>определенная **спецификация функционала**</mark>.

 Если вы планируете написать код, который может использоваться как в приложениях .Net Framework, так и в приложениях .Net Core, то вы должны писать код, как библиотеку **.Net Standard** подбирая версию таким образом, чтобы она работала с версиями с .Net Framework и .Net Core для которых вы пишете это приложение.

---

### #25 Выражения LINQ

Поступило задание добавить в данный класс некий новый метод, который расширяет функциональность данного класса. Давайте подумаем какие возможности у нас есть.

1. мы можем попробовать наследовать данный класс и в классе-наследнике сделать имплементацию метода, который необходим нашим пользователям;
2. мы можем использовать композицию и шаблон проектирования «Декоратор», чтобы добавить интересующий нас метод.

К сожалению, ни один из предложенных методов не является идеальным.

Однако в языке программирования C# можно использовать такую функциональность, как **методы расширения** или **Extension Methods**. Если коротко, то методы расширения позволяют нам добавить функциональность к типам, значимым и ссылочным, не изменяя код этих типов, не прибегая к наследованию и композиции, не использую шаблоны проектирования.

```C#
namespace XYZ
{
    static class StringExtensions
    {
        public static IEnumerable<char> ToCharEnumerable(this String @string)
        {
            var result = new List<char>();
            for (int i = 0; i < @string.Length; i++)
                result.Add(@string[i]);
            return result;
        }
    }
}
```

Давайте подумаем, что необходимо сделать чтобы создать класс:

- определить публичные и приватные поля и свойства;
- переопределить метод ToString() – для удобства логирования;
- переопределить методы GetHashCode() / Equals() – для сравнения объектов на основании значений их свойств, а не ссылок на определенное место в памяти;

**создание анонимных типов**

```C#
 double min = 0.5;
     double max = 1.44;
     string description = "Some description";
 var anonymous = new { Min = min, Max = max, Description = description };
```

Как и любой другой тип в языке C# анонимный тип наследует тип System.Object, то есть в нашем анонимном типе доступны стандартные 4 метода: **ToString()**, **GetHashCode()**, **Equals()**, **GetType()**. Рассмотрим каждый из этих методов анонимного типа:

- **ToString()** выведет на экран следующую строку: { Min = 0,5, Max = 1,44, Description = Some description } – как видите метод ToString() выводит на экран строку, которая содержит названия свойств и их значения без дополнительного переопределения данного метода;
- **GetHashCode()** – данный метод рассчитывает хэш код на основании названий свойств и их значений, то есть можно сделать вывод, что для двух анонимных типов с одинаковыми свойствами и одинаковыми значениями свойств будут возвращены одинаковые хэш коды.
- **Equals()** – данный метод вернет значение True для двух анонимных типов с одинаковыми свойствами и одинаковыми значениями. Метод Equals анонимного типа основан на значениях и названиях свойств, однако оператор равенства «==» будет сравнивать ссылки и если объекты анонимного типа хранятся под разными адресами в памяти результат сравнения будет false, несмотря на равенство значений и названий свойств.
- **GetType()** вернёт некую строку похожую на «f__AnonymousType0 3[System.Double,System.Double,System.String]». Стоит сказать, что у нас не будет доступа к названию анонимного типа и название которое мы получили при помощи метода GetType() автоматически сгенерировано компилятором. В любом случае название анонимного типа не влияет на нашу работу и как оно выглядит не должно нас волновать. Важно только сказать, что если бы создали еще один анонимный тип используя следующую строчку кода

```
var anonymous2 = new { Min = 2.0, Max = 10.5, Description = “description” };
```

то компилятор не создал бы новый анонимный тип а использовал существующий тип, так как тип переменной anonymous2 содержит тот же набор свойств (названия и типы), как и созданная ранее переменная anonymous.

**выражения лямбда**

    **Аргументы для обработки => Операции над аргументами**

```
i => i > 0;
```

```
(int x, int y) => {
var result = x + y;
 Console.WriteLine($“Result is {result}”);
 return result;
}
```

**LINQ**

То есть «язык интегрированных запросов» - можно сказать, что это некий <mark>язык</mark>, который интегрирован в язык C# и который <mark>позволяет получать</mark> и модифицировать <mark>данные из различных источников</mark> <mark>стандартным образом</mark> независимо от физического характера источника данных.

Возникает резонный вопрос, функциональность каких типов мы расширяем? Ответ на этот вопрос, следующий: всех типов, которые имплементируют интерфейс IEnumerable, то есть все типы, которые можно перечислять: массивы, списки, словари, различные коллекции.

Следует также помнить, что **методы <mark>LINQ выполняются отложенным</mark> выполнением**, то есть выражение orderedEven <mark>содержит выражение LINQ</mark>, а <mark>не результат</mark> его <mark>выполнения</mark>.



интерфейс **IEnumerable** или **IQueryable**

- если вы ожидаете результат вашего запроса как IQueryable, то логика вашего запроса будет выполнена в базе данных (LINQ-to-SQL) и вы получите уже готовый результат из базы.
- если вы ожидаете результат вашего запроса как IEnumerable, то логика вашего запроса будет выполнена в коде (LINQ-to-objects): сначала вы получите все данные из базы, а потом отфильтруете нужные вам данные в коде и получите готовый результат.

По факту разница сводится к тому, где вы хотели бы выполнить логику вашего запроса – в базе (IQueryable) или в коде (IEnumerable). Вы можете явно это указать используя методы LINQ **AsQueryable()** и **AsEnumerable()**.



```
class Statistic
    {
        public string Name { get; set; }
        public double Avg { get; set; }
        public double Min { get; set; }
        public double Max { get; set; }
    }

var list = new List<Statistic>(new[] {
                new Statistic(){
                    Name="Test A",
                    Avg = 23.4,
                    Min = 11.3,
                    Max = 25.6
                },
                new Statistic(){
                    Name="Test B",
                    Avg = 22.4,
                    Min = 9.3,
                    Max = 27.6
                }});

var maxData = list.Select(s => new {s.Name, s.Max });
```

---

### #26  Продвинутые функции языка C#

- использованием индексов
- переопределением операторов
- продвинутой конверсией типов

```
class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("ПРИМЕР 1. Индексы.");

            var x = new NamedValue("X", 2.54M);
            var y = new NamedValue("Y", 3.46M);
            var z = new NamedValue("Z", 3.46M);

            var data = new[] { x, y };

            var typeWithIndex = new TypeWithIndex(data);


            Console.WriteLine("\nИспользование индекса по свойству Name.");
            Console.WriteLine(typeWithIndex["X"]); // 2.54
            Console.WriteLine(typeWithIndex["Y"]); // 3.46
            Console.WriteLine(typeWithIndex["Z"]); // 0

            Console.WriteLine("\nИспользование индекса по свойству Value.");
            Console.WriteLine(typeWithIndex[2.54M]); // X
            Console.WriteLine(typeWithIndex[3.46M]); // Y
            Console.WriteLine(typeWithIndex[0M]); // Z

            Console.WriteLine("\nИспользование метода поиска по свойству Name.");
            Console.WriteLine(typeWithIndex.GetByName("X")); // 2.54
            Console.WriteLine(typeWithIndex.GetByName("Y")); // 3.46
            Console.WriteLine(typeWithIndex.GetByName("Z")); // 0

            Console.WriteLine("\nИспользование метода поиска по свойству Value.");
            Console.WriteLine(typeWithIndex.GetByValue(2.54M)); // X
            Console.WriteLine(typeWithIndex.GetByValue(3.46M)); // Y
            Console.WriteLine(typeWithIndex.GetByValue(0M)); // Z


            Console.ReadKey();
        }
    }

internal class NamedValue
    {
        public NamedValue(string name, decimal value)
        {
            Name = name;
            Value = value;
        }

        public string Name { get; set; }

        public decimal Value { get; set; }


        public static NamedValue operator +(NamedValue x, NamedValue y) => new NamedValue($"{x.Name} + {y.Name}", x.Value + y.Value);

        public static NamedValue operator -(NamedValue x, NamedValue y) => new NamedValue($"{x.Name} - {y.Name}", x.Value - y.Value);

        public static NamedValue operator *(NamedValue x, NamedValue y) => new NamedValue($"{x.Name} * {y.Name}", x.Value * y.Value);

        public static NamedValue operator /(NamedValue x, NamedValue y) => new NamedValue($"{x.Name} / {y.Name}", x.Value / y.Value);

        public static bool operator ==(NamedValue x, NamedValue y) => x.Value == y.Value;

        public static bool operator !=(NamedValue x, NamedValue y) => x.Value != y.Value;

        public static bool operator <(NamedValue x, NamedValue y) => x.Value < y.Value;

        public static bool operator >(NamedValue x, NamedValue y) => x.Value > y.Value;

        public static bool operator <=(NamedValue x, NamedValue y) => x.Value <= y.Value;

        public static bool operator >=(NamedValue x, NamedValue y) => x.Value >= y.Value;

        public override string ToString() => $"{Name} = {Value}";

        public override int GetHashCode() => ToString().GetHashCode();

        public override bool Equals(object obj) => ToString().GetHashCode() == obj.GetHashCode();
    }

class TypeWithIndex : ITypeWithIndex
    {
        private readonly IEnumerable<NamedValue> _internalCollection;

        public TypeWithIndex(IEnumerable<NamedValue> data)
        {
            _internalCollection = data;
        }

        public decimal this[string index]
        {
            get => _internalCollection.FirstOrDefault(i => i.Name == index)?.Value ?? 0M;
        }

        public string this[decimal index]
        {
            get => _internalCollection.FirstOrDefault(i => i.Value == index)?.Name ?? "[EMPTY]";
        }

        public decimal GetByName(string name) => _internalCollection.FirstOrDefault(i => i.Name == name)?.Value ?? 0M;

        public string GetByValue(decimal value) => _internalCollection.FirstOrDefault(i => i.Value == value)?.Name ?? "[EMPTY]";
    }

interface ITypeWithIndex
    {
        decimal this[string index] { get; }

        string this[decimal index] { get; }

        decimal GetByName(string name);

        string GetByValue(decimal value);
    }
```

```
var a = new SomeClassA();
var b = (SomeClassB) a;
class SomeClassA { }
class SomeClassB { }
```

```
class Program
    {
        static void Main(string[] args)
        {

            Console.WriteLine("\nПРИМЕР 3. Конверсия типов.");

            var mobile = new Mobile(5.2M, "Apple IOS");
            Console.WriteLine();
            Console.WriteLine(mobile);
            Console.WriteLine("Конверсия...");
            var tablet = (Tablet)mobile;
            Console.WriteLine(tablet);           

            Console.ReadKey();
        }
    }

class Mobile
    {
        public Mobile(decimal size, string operatingSystem)
        {
            DisplaySize = size;
            OperatingSystem = operatingSystem;
        }

        public decimal DisplaySize { get; }

        public string OperatingSystem { get; }

        public override string ToString() => $"Mobile => {DisplaySize}'', {OperatingSystem}";
    }

class Tablet
    {
        public Tablet(decimal size, string operatingSystem, bool supportsGsm)
        {
            DisplaySize = size;
            OperatingSystem = operatingSystem;
            SupportsGsm = supportsGsm;
        }

        public decimal DisplaySize { get; }

        public string OperatingSystem { get; }

        public bool SupportsGsm { get; }

        public override string ToString() => $"Tablet => {DisplaySize}'', {OperatingSystem}, GSM: {SupportsGsm}";

        public static explicit operator Tablet(Mobile mobile)
        {
            return new Tablet(mobile.DisplaySize * 2, mobile.OperatingSystem, true);
        }
    }
```



---

### #27 Тип string в языке C#

---

### #28

---

### #29

---

### #30

---

### #31

---

### #32

---

### #33

---

### #34

---

### #35

---

### #36

---

### #37

---

### #38

---
